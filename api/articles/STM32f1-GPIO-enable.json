{"title":"STM32f1 GPIO enable","slug":"STM32f1-GPIO-enable","date":"2021-08-18T12:10:52.000Z","updated":"2021-09-03T14:39:44.429Z","comments":true,"path":"api/articles/STM32f1-GPIO-enable.json","photos":[],"link":"","excerpt":"STM32F1系列HAL库配置GPIO前言（废话）","covers":["https://img-blog.csdnimg.cn/9a6f90547e774cb1a7a869a477eff231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/181bc76397934379bd9b20b5bba883c0.png","https://img-blog.csdnimg.cn/81b02e5455514c9885bfd8e9303fd6d5.png","https://img-blog.csdnimg.cn/6ba4d549c70f4e9eae5c90c63e54d118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/80b384bb584b4c008cca3f475da024b1.png","https://img-blog.csdnimg.cn/c8d9deda9d9e45888950bdf838006fe7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70"],"content":"<h1 id=\"STM32F1系列HAL库配置GPIO\"><a href=\"#STM32F1系列HAL库配置GPIO\" class=\"headerlink\" title=\"STM32F1系列HAL库配置GPIO\"></a>STM32F1系列HAL库配置GPIO</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=409872504&auto=1&height=66\"></iframe>\n\n<h2 id=\"前言（废话）\"><a href=\"#前言（废话）\" class=\"headerlink\" title=\"前言（废话）\"></a>前言（废话）</h2><span id=\"more\"></span>\n\n<p>老早就被安利了stm32CUBEMX，只是当时特别懒，也没啥感觉，如今看来真的是不知好歹了我。相比较标准库，HAL库十分方便快捷，相当于你直接跳过了各种复杂的配置，直接来到应用层，并且只要明白库中函数如何使用，基本上就可以写了，比起早已不更新的标准库，HAL库的优势不至于此，虽说看懂标准库也十分重要，但是过程却是当你痛苦的go to definition,发现你根本看不懂，又烦又长<br><img src=\"https://img-blog.csdnimg.cn/9a6f90547e774cb1a7a869a477eff231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>但是，cubemx真的解放了我的眼睛和手，<br><img src=\"https://img-blog.csdnimg.cn/181bc76397934379bd9b20b5bba883c0.png\" alt=\"在这里插入图片描述\"><br>我一个手癌选手激动的都要叫出来了<img src=\"https://img-blog.csdnimg.cn/5584ac5cc9684a4a95effc25317c582e.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"GPIO的简单介绍\"><a href=\"#GPIO的简单介绍\" class=\"headerlink\" title=\"GPIO的简单介绍\"></a>GPIO的简单介绍</h2><p>1.<strong>GPIO</strong>（英语：General-purpose input&#x2F;output），通用型之输入输出的简称，其接脚可以供使用者由程序控制自由使用，PIN 脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO）<br>2.<strong>GPIO</strong>有八种工作模式，虽然我们只是使用其中几个模式，但是还是有必要说明一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GPIO_Mode_AIN 模拟输入</span><br><span class=\"line\">GPIO_Mode_IN_FLOATING 浮空输入</span><br><span class=\"line\">GPIO_Mode_IPD 下拉输入</span><br><span class=\"line\">GPIO_Mode_IPU 上拉输入</span><br><span class=\"line\">GPIO_Mode_Out_OD 开漏输出</span><br><span class=\"line\">GPIO_Mode_Out_PP 推挽输出</span><br><span class=\"line\">GPIO_Mode_AF_OD 复用开漏输出</span><br><span class=\"line\">GPIO_Mode_AF_PP 复用推挽输出</span><br></pre></td></tr></table></figure>\n<p>应用场景说明（不全）：<br>1、上拉输入、下拉输入可以用来检测外部信号；例如，按键等，这种我们是比较常用，按键检测使用到的；<br>2、浮空输入模式，由于输入阻抗较大，一般把这种模式用于标准通信协议的 I2C、USART 的接收端；<br>3、普通推挽输出模式一般应用在输出电平为 0 和 3.3V 的场合。（常用）而普通开漏输出模式一般应用在电平不匹配的场合，如需要输出 5V 的高电平，就需要在外部一个上拉电阻，电源为 5V，把 GPIO 设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出 5V 电平。<br>4、对于相应的复用模式（复用输出来源片上外设），则是根据 GPIO 的复用功能来选择，如 GPIO 的引脚用作串口的输出（USART&#x2F;SPI&#x2F;CAN），则使用复用推挽输出模式。如果用在 I2C、SMBUS 这些需要线与功能的复用场合，就使用复用开漏模式。<br>5、在使用任何一种开漏模式时，都需要接上拉电阻。（一般都已接好）<br>你们也可以看这个帖子了解到更多：<a href=\"http://www.openedv.com/posts/list/32730.htm\">具体模式使用场景</a></p>\n<h2 id=\"CUBEMX的相关配置\"><a href=\"#CUBEMX的相关配置\" class=\"headerlink\" title=\"CUBEMX的相关配置\"></a>CUBEMX的相关配置</h2><p>1.打开CUBEMX，选择你所使用的芯片，我所使用的STM32F103C8T6，</p>\n<p><img src=\"https://img-blog.csdnimg.cn/81b02e5455514c9885bfd8e9303fd6d5.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/9ebea5a0875d4334b6c568eb88eb56f3.png\" alt=\"在这里插入图片描述\"><br>点击进入配置页面，<br> <strong>选择引脚类型</strong><br>GPIO_Input-输入引脚 GPIO_Output-输出引脚<br><img src=\"https://img-blog.csdnimg.cn/ab8290baeeca41308837761e12aece41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"单击\"><br>单击你所要配置的引脚，如我用PA0为输入引脚，PA1为输出引脚；<br><strong>输入引脚配置</strong>：对于输入引脚，可以配置的就是 <strong>GPIO Pull-up&#x2F;Pull-down</strong>。这分别对应的就是 Pull-up（输入上拉）与 Pull-down （输入下拉）。<br><strong>Pull-up</strong>: 输入上拉就是把电位拉高，比如拉到 Vcc。上拉就是将不确定的信号通过一个电阻嵌位在高电平。即不管你之前是高电压也好是低电压也罢，我通过pull-up都可以上拉到高电平，电阻同时起到限流的作用。弱强只是上拉电阻的阻值不同，没有什么严格区分。<br><strong>Pull-down</strong>: 输入下拉就是把电压拉低，拉到 GND。与上拉相似。<br>&#x3D;&#x3D;简单的说&#x3D;&#x3D;，如果你希望你的引脚平时处于高电平用于检测低电平，你就使用 Pull-up。如果你希望你的引脚平时处于低电平用于检测高电平，你就使用 Pull-down<br><img src=\"https://img-blog.csdnimg.cn/3970bf594f544bc3a302eca3943c73c6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><strong>输出引脚配置</strong>：<br><strong>GPIO output level</strong> -&gt; 初始化输出电平<br><strong>GPIO mode</strong> -&gt; 输出方式 -&gt; 开漏或推挽输出<br><strong>GPIO Pull-up&#x2F;Pull-down</strong> -&gt; 上拉或下拉输出<br><strong>Maximum output speed</strong> 选中 GPIO 管脚的速率</p>\n<p>I&#x2F;O 口的输出模式下，有 3 种输出速度可选 (Low - 2MHz、Medium - 10MHz、High -50MHz)，这个速度是指 I&#x2F;O 口驱动电路的响应速度而不是输出信号的速度，输出信号的速度与程序有关（芯片内部在 I&#x2F;O 口的输出部分安排了多个响应速度不同的输出驱动电路，用户可以根据自己的需要选择合适的驱动电路）。通过选择速度来选择不同的输出驱动模块，达到最佳的噪声控制和降低功耗的目的。高频的驱动电路，噪声也高，当不需要高的输出频率时，请选用低频驱动电路，这样非常有利于提高系统的 EMI 性能。当然如果要输出较高频率的信号，但却选用了较低频率的驱动模块，很可能会得到失真的输出信号。<br>举个例子：<br>1、USART 串口，若最大波特率只需 115.2k，那用 2M 的速度就够了，既省电也噪声<br>小。<br>2、I2C 接口，若使用 400k 波特率，若想把余量留大些，可以选用 10M 的 GPIO 引<br>脚速度。<br>3、SPI 接口，若使用 18M 或 9M 波特率，需要选用 50M 的 GPIO 的引脚速度<br>我们一般保持系统默认，有需要时拉高拉低。<br><img src=\"https://img-blog.csdnimg.cn/6ba4d549c70f4e9eae5c90c63e54d118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>然后，对于clock config我们之后再讲，但现在不需要管他，在project manager配置<br><img src=\"https://img-blog.csdnimg.cn/6015a8401259494da0985fce181db810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>Project name名字自取，&#x3D;&#x3D;一定不要包含中文&#x3D;&#x3D;， &#x3D;&#x3D;一定不要包含中文&#x3D;&#x3D;   ，&#x3D;&#x3D;一定不要包含中文&#x3D;&#x3D;；<br>路径也是，不要包含中文，并且这还牵扯到这里是否可写可读，我们为方便起见，用管理员权限打开CUBEMX，放到合适的文件下，通过属性修改读写方式。<br>我们的IDE是KEIL，所以选MDK-ARM，并选择对应版本；<br>后面两项一定要相同，我的都是V1.8.4<br>各方面都配置好了就可以点击右上角的&#x3D;&#x3D;GENERATE CODE&#x3D;&#x3D;<img src=\"https://img-blog.csdnimg.cn/3b859e23e53548fb84d00aacddd2061e.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"应用代码介绍\"><a href=\"#应用代码介绍\" class=\"headerlink\" title=\"应用代码介绍\"></a>应用代码介绍</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//初始化引脚</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_GPIO_Init</span><span class=\"params\">(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span>;</span><br><span class=\"line\"><span class=\"comment\">//重置引脚</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_GPIO_DeInit</span><span class=\"params\">(GPIO_TypeDef *GPIOx, <span class=\"type\">uint32_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>\n<p>初始化CUBEMX已经帮你配好了，他们你需要再配置其他的再用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读取电平状态</span></span><br><span class=\"line\">GPIO_PinState <span class=\"title function_\">HAL_GPIO_ReadPin</span><span class=\"params\">(GPIO_TypeDef *GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置引脚状态</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_GPIO_WritePin</span><span class=\"params\">(GPIO_TypeDef *GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin, GPIO_PinState</span></span><br><span class=\"line\"><span class=\"params\">PinState)</span>;</span><br><span class=\"line\"><span class=\"comment\">//转换引脚状态</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_GPIO_TogglePin</span><span class=\"params\">(GPIO_TypeDef *GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span>;</span><br><span class=\"line\"><span class=\"comment\">//锁定引脚状态</span></span><br><span class=\"line\">HAL_StatusTypeDef <span class=\"title function_\">HAL_GPIO_LockPin</span><span class=\"params\">(GPIO_TypeDef *GPIOx, <span class=\"type\">uint16_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>\n<p>在STM32F1开发指南-HAL库版本上有对这些函数的详细说明，<img src=\"https://img-blog.csdnimg.cn/80b384bb584b4c008cca3f475da024b1.png\" alt=\"在这里插入图片描述\"></p>\n<p>同时 HAL 库帮我定义好了 GPIO_PIN_RESET 与 GPIO_PIN_SET，代表着 1（高电平）、0（低电平）。<br>如果你要用他来点灯，需要看好引脚，设置输出模式，或者用按键控制，你需要加一个输入模式，相当于电平检测<br>*<em>读取电平状态<br>GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef <em>GPIOx, uint16_t GPIO_Pin);</em></em><br><code>if(HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)==GPIO_PIN_SET)</code><br>就这样，后面写HAL_GPIO_WritePin这些函数，<br><strong>另外，使用好User label也很好</strong>，对于任意引脚，它都有这么一个选项。我想告诉你这个选项特别特别好用！这个选项简单的说就是它帮你在 main.h 中生成 define 语句。但是对于 HAL 库编程，main.h 会被用户的每个模块调用，也就是这些 define 语句的作用域几乎是全局。这个后面会讲到。</p>\n<p>控制好这些也很好呢！<br><img src=\"https://img-blog.csdnimg.cn/c8d9deda9d9e45888950bdf838006fe7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","categories":[{"name":"基本功能食用","slug":"基本功能食用","count":10,"path":"api/categories/基本功能食用.json"}],"tags":[{"name":"STM32","slug":"STM32","count":10,"path":"api/tags/STM32.json"},{"name":"基本外设","slug":"基本外设","count":8,"path":"api/tags/基本外设.json"},{"name":"HAL库","slug":"HAL库","count":8,"path":"api/tags/HAL库.json"},{"name":"大一课程准备","slug":"大一课程准备","count":10,"path":"api/tags/大一课程准备.json"}]}