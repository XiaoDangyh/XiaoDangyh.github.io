{"title":"STM32F1 usart usage and HAL config-2","slug":"STM32F1-usart-usage-and-HAL-config-2","date":"2021-08-18T12:20:27.000Z","updated":"2021-09-03T14:35:31.149Z","comments":true,"path":"api/articles/STM32F1-usart-usage-and-HAL-config-2.json","photos":[],"link":"","excerpt":"串口重定向以及log信息格式输出之前我们提到了HAL库配置串口，但是由于我们还没有进行到中断，所以对于一些HAL库里有关串口的函数还是很难全部应用的，尽管如此，我们依然可以借助这两个函数胡作非为 加以利用。","covers":["https://img-blog.csdnimg.cn/724c9ac0824343ac931567608ee5a92b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/e1b6569099b14bae9ce96c6667e9149f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/d0ed3040a16542fe8109c484d4eef869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/526ae70b173a41b69b3d836cfae58f86.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/8de65728f8b9490ebac23c9b49d3f053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70"],"content":"<h1 id=\"串口重定向以及log信息格式输出\"><a href=\"#串口重定向以及log信息格式输出\" class=\"headerlink\" title=\"串口重定向以及log信息格式输出\"></a>串口重定向以及log信息格式输出</h1><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=1849358169&auto=1&height=66\"></iframe>\n\n<p>之前我们提到了HAL库配置串口，但是由于我们还没有进行到中断，所以对于一些HAL库里有关串口的函数还是很难全部应用的，尽管如此，我们依然可以借助这两个函数<del>胡作非为</del> 加以利用。</p>\n<span id=\"more\"></span>\n\n<p><strong>1.串口发送数据：</strong></p>\n<p>HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)<br>功能：串口发送指定长度的数据。如果超时没发送完成，则不再发送，返回超时标志（HAL_TIMEOUT）。</p>\n<p><strong>参数：</strong></p>\n<p>*<em>UART_HandleTypeDef <em>huart</em></em>      UATR的别名    如 :   UART_HandleTypeDef huart1;   别名就是huart1<br>*<strong>pData</strong>      需要发送的数据<br><strong>Size</strong>    发送的字节数<br><strong>Timeout</strong>   最大发送时间，发送数据超过该时间退出发送<br>举例：   HAL_UART_Transmit(&amp;huart1, (uint8_t *)ZZX, 3, 0xffff);   &#x2F;&#x2F;串口发送三个字节数据，最大传输时间0xffff</p>\n<p><strong>2.中断接收数据：</strong><br>HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)<br>功能：串口接收指定的长度的数据，<br>参数与发送函数的基本相同。<br>大家可以看一下这篇博主的介绍会更详细<a href=\"https://blog.csdn.net/as480133937/article/details/9907378\">UART串口通信详解</a><br>在研究标准库的时候，使用了串口重定向，采用printf与scanf等等C语言学习时经常用到的函数，并且当我们配置好的时候，还可以利用gets，puts，getchar与putchar，十分方便，这样也减少了你重新写HAL_UART_Transmit等这些函数的时间。&#x3D;&#x3D;可为什么要重定向呢&#x3D;&#x3D;？<br>建议大家先看一下这篇博客<a href=\"https://blog.csdn.net/qq_29344757/article/details/75363639?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162909509816780262558976%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162909509816780262558976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-75363639.pc_search_similar&utm_term=%20printf%20%E9%87%8D%E5%AE%9A%E5%90%91&spm=1018.2226.3001.4187\">STM32的printf函数重定向</a><br>我们的KEIL里是有microLib库，他支持我们使用不太健全的stdio.h，这样我们就可以使用printf等上述提到的输入输出函数了，<br><img src=\"https://img-blog.csdnimg.cn/724c9ac0824343ac931567608ee5a92b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>不过，我们在VS里printf的内容是显示在窗口控制台里，而这样直接使用printf()函数，其打印的字符串最终&#x3D;&#x3D;不知道打印到何处&#x3D;&#x3D;。我们要做的是将调试信息&#x3D;&#x3D;打印到USART1&#x3D;&#x3D;中，所以需要对printf()函数所依赖的打印输出函数fputc()重定向<br>(因为MicroLib中的printf()函数打印操作依赖fputc())<br>在MicroLib的stdio.h中，fputc()函数的原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE* stream)</span></span><br></pre></td></tr></table></figure>\n<p>此函数原本是将字符ch打印到文件指针stream所指向的文件流去的，现在我们不需要打印到文件流，而是打印到串口1。<br>利用HAL_UART_Transmit打印到串口1</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">uint8_t</span> temp[<span class=\"number\">1</span>] = &#123;ch&#125;;</span><br><span class=\"line\">HAL_UART_Transmit(&amp;huart1, temp, <span class=\"number\">1</span>, <span class=\"number\">2</span>);<span class=\"comment\">//huart1需要根据你的配置修改</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相应的，fgets也可以重定向</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fgetc</span><span class=\"params\">(FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span> ch = <span class=\"number\">0</span>;</span><br><span class=\"line\">  HAL_UART_Receive(&amp;huart1, &amp;ch, <span class=\"number\">1</span>, <span class=\"number\">0xffff</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>别忘了添加stdio.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* USER CODE BEGIN Includes */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* USER CODE END Includes */</span></span><br><span class=\"line\">注意加在begin与end之间，否则报错</span><br></pre></td></tr></table></figure>\n<p>这样就可以使用printf，gets，puts等函数了，这里给大家举个栗子：<br>main函数内初始化str字符数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">100</span>];</span><br></pre></td></tr></table></figure>\n<p>while（1）里添加</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gets(str);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;三句话，让我听了%s\\r\\n&quot;</span>,str);</span><br></pre></td></tr></table></figure>\n<p>编译无误后运行<br><img src=\"https://img-blog.csdnimg.cn/e1b6569099b14bae9ce96c6667e9149f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>（这里记得勾选发送新行！）<br>也可以试试这些！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch;</span><br><span class=\"line\"><span class=\"keyword\">while</span>（<span class=\"number\">1</span>）</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ch=getchar();</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(ch);</span><br><span class=\"line\">\t<span class=\"comment\">//\tgets(str);</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tscanf(&quot;%s&quot;,str);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"个性化输出\"><a href=\"#个性化输出\" class=\"headerlink\" title=\"个性化输出\"></a>个性化输出</h2><p>除此以外，介绍个小网站<a href=\"http://patorjk.com/software/taag/#p=display&f=Cards&t=adidas\">Text to ASCII Art Generator (TAAG)</a><br>在最中间的方框输入你想要的文字，设置Font，一行一行复制到printf中<br><img src=\"https://img-blog.csdnimg.cn/d0ed3040a16542fe8109c484d4eef869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>比如我这里设置Crads字体，输出adidas，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//\t\t    printf(&quot;.------..------..------..------..------..------.\\r\\n&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;|A.--. ||D.--. ||I.--. ||D.--. ||A.--. ||S.--. |\\r\\n&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;| (\\\\/) || :/\\\\: || (\\\\/) || :/\\\\: || (\\\\/) || :/\\\\: |\\r\\n&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;| :\\\\/: || (__) || :\\\\/: || (__) || :\\\\/: || :\\\\/: |\\r\\n&quot;);\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;| &#x27;--&#x27;A|| &#x27;--&#x27;D|| &#x27;--&#x27;I|| &#x27;--&#x27;D|| &#x27;--&#x27;A|| &#x27;--&#x27;S|\\r\\n&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;`------&#x27;`------&#x27;`------&#x27;`------&#x27;`------&#x27;`------&#x27;\\r\\n&quot;);\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t    printf(&quot;---------------------------------------------------\\r\\n&quot;);</span></span><br></pre></td></tr></table></figure>\n<p>&#x3D;&#x3D;注意红线，你只需在前加\\，变为转义字符即可&#x3D;&#x3D;<br>效果如下：<br><img src=\"https://img-blog.csdnimg.cn/526ae70b173a41b69b3d836cfae58f86.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"利用条件编译，可变参数宏实现log信息格式输出\"><a href=\"#利用条件编译，可变参数宏实现log信息格式输出\" class=\"headerlink\" title=\"利用条件编译，可变参数宏实现log信息格式输出\"></a>利用条件编译，可变参数宏实现log信息格式输出</h2><p>了解c语言的都应该知道，条件编译，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> LOG</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[info]main.c:&quot;</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>他的意思就是说，if判断LOG（即为1），那么执行printf语句，如果我们去掉1或者整句去掉，就不会执行#if与#endif之间的语句。</p>\n<p>可变参数宏也很好理解</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USER_MAIN_DEBUG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_printf(format, ...) printf( format <span class=\"string\">&quot;\\r\\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_printf(format, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>如果我们定义了USER_MAIN_DEBUG，那么就#define       user_main_printf(format, …)为printf( format “\\r\\n”, ##_<strong>VA_ARGS</strong>)，<br>否则执行#define user_main_printf(format, …)，这句相当于把这句直接废掉，因为他定义成了一个空白，什么都没有。<br>而这句&#x3D;&#x3D;printf( format “\\r\\n”, ##_<strong>VA_ARGS</strong>)&#x3D;&#x3D;，相当于把你在user_main_printf（“111222”）中，111222后加了\\r\\n。<br>这个是我无意中听到B站一个大佬讲的<a href=\"https://www.bilibili.com/video/BV1q4411d7RX?p=13&spm_id_from=pageDriver\">可变参数宏</a>知道的。<br>利用这个，我在主函数中直接写user_main_info（“我想写的东西”）；就会显示：**[\\tmain]info:我想写的东西**</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_MAIN_DEBUG 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> USER_MAIN_DEBUG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_printf(format, ...) printf( format <span class=\"string\">&quot;\\r\\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_info(format, ...) printf(<span class=\"string\">&quot;[\\tmain]info:&quot;</span> format <span class=\"string\">&quot;\\r\\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_debug(format, ...) printf(<span class=\"string\">&quot;[\\tmain]debug:&quot;</span> format <span class=\"string\">&quot;\\r\\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_error(format, ...) printf(<span class=\"string\">&quot;[\\tmain]error:&quot;</span> format <span class=\"string\">&quot;\\r\\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_printf(format, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_info(format, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_debug(format, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> user_main_error(format, ...)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>注意这个只在C99当中成立，C89会报错。当我需要打印串口信息的时候，define 一个 USER_MAIN_DEBUG, 在我不需要时将<br>其注释。<br>之后再讲串口中断吧。<br><img src=\"https://img-blog.csdnimg.cn/8de65728f8b9490ebac23c9b49d3f053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","categories":[{"name":"基本功能食用","slug":"基本功能食用","count":10,"path":"api/categories/基本功能食用.json"}],"tags":[{"name":"STM32","slug":"STM32","count":10,"path":"api/tags/STM32.json"},{"name":"基本外设","slug":"基本外设","count":8,"path":"api/tags/基本外设.json"},{"name":"HAL库","slug":"HAL库","count":8,"path":"api/tags/HAL库.json"},{"name":"大一课程准备","slug":"大一课程准备","count":10,"path":"api/tags/大一课程准备.json"}]}