{"title":"python-learn-3","slug":"python-learn-3","date":"2022-02-15T06:16:54.000Z","updated":"2022-02-15T06:25:29.030Z","comments":true,"path":"api/articles/python-learn-3.json","photos":[],"link":"","excerpt":" [Figure] ","covers":["https://tse1-mm.cn.bing.net/th/id/R-C.4b4ec93aa91477d76cd4a50ec749b3f8?rik=I3Gdwho2//wbvg&riu=http://i2.hdslb.com/bfs/archive/436be3431b2c2a461dcc93b66fbc0e820e597718.jpg&ehk=rBkZ238pIOJb+ajQZVpv08xyMEe/9L+nQfir1nqZstc=&risl=&pid=ImgRaw&r=0"],"content":"<p><img src=\"https://tse1-mm.cn.bing.net/th/id/R-C.4b4ec93aa91477d76cd4a50ec749b3f8?rik=I3Gdwho2//wbvg&riu=http://i2.hdslb.com/bfs/archive/436be3431b2c2a461dcc93b66fbc0e820e597718.jpg&ehk=rBkZ238pIOJb+ajQZVpv08xyMEe/9L+nQfir1nqZstc=&risl=&pid=ImgRaw&r=0\" alt=\"查看源图像\"></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=530 height=86 src=\"//music.163.com/outchain/player?type=2&id=409931573&auto=0&height=66\"></iframe>\n\n<span id=\"more\"></span>\n\n<h1 id=\"1-28-python学习笔记\"><a href=\"#1-28-python学习笔记\" class=\"headerlink\" title=\"1.28 python学习笔记\"></a>1.28 python学习笔记</h1><hr>\n<h3 id=\"返回函数：\"><a href=\"#返回函数：\" class=\"headerlink\" title=\"返回函数：\"></a>返回函数：</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calc_sum</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    ax = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        ax = ax + n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ax</span><br></pre></td></tr></table></figure>\n\n<p>返回求和函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">lazy_sum</span>(<span class=\"params\">*args</span>):<span class=\"comment\">#可变参数上移了</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sum</span>():</span><br><span class=\"line\">        ax = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">            ax = ax + n</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ax</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sum</span><span class=\"comment\">#返回函数</span></span><br></pre></td></tr></table></figure>\n\n<p>所以调用lazy_sum时，返回的不是求和结果，而是求和函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f</span><br><span class=\"line\">&lt;function lazy_sum.&lt;<span class=\"built_in\">locals</span>&gt;.<span class=\"built_in\">sum</span> at <span class=\"number\">0x101c6ed90</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f()<span class=\"comment\">#调用函数f时，才真正计算求和的结果：</span></span><br><span class=\"line\"><span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>闭包：</strong>在lazy_sum中又定义了函数sum，内部函数sum可以引用外部函数的参数和局部变量，当lazy——sum返回函数sum，相关参数和变量都保存在返回的函数中</p>\n<p>当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1==f2</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>\n<p>注意：返回的函数没有立刻被执行，而是调用了f（）才执行，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">count</span>():</span><br><span class=\"line\">\tfs=[]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>):</span><br><span class=\"line\">\t <span class=\"keyword\">def</span> <span class=\"title function_\">f</span>():</span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> i*i</span><br><span class=\"line\">\t fs.append(f)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs</span><br><span class=\"line\">\t</span><br><span class=\"line\">f1,f2,f3=count()</span><br><span class=\"line\">你可能认为调用f1()，f2()和f3()结果应该是<span class=\"number\">1</span>，<span class=\"number\">4</span>，<span class=\"number\">9</span>，但实际结果是：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</span><br><span class=\"line\"><span class=\"number\">9</span>\t </span><br></pre></td></tr></table></figure>\n\n<p>原因在于返回的函数引用了变量i，但他并非立刻执行，等到三个函数都返回，他们的引用的变量变成了3，更注意的是，虽然调用数值相等，但是调用结果互不影响</p>\n<p><em><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong></em></p>\n<h1 id=\"闭包会保存循环变量！！！！！！\"><a href=\"#闭包会保存循环变量！！！！！！\" class=\"headerlink\" title=\"闭包会保存循环变量！！！！！！\"></a>闭包会保存循环变量！！！！！！</h1><p>那如果一定要引用循环怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量，无论循环变量后续如何更改，已绑定到函数参数的值不变：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">count</span>():</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">f</span>(<span class=\"params\">j</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">def</span> <span class=\"title function_\">g</span>():</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> j*j</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">\tfs=[]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>):</span><br><span class=\"line\">\t\tfs.append(f(i))<span class=\"comment\"># f(i)立刻被执行，因此i的当前值被传入f()</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs</span><br></pre></td></tr></table></figure>\n\n<p>再看看结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1, f2, f3 = count()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"nonlocal\"><a href=\"#nonlocal\" class=\"headerlink\" title=\"nonlocal:\"></a>nonlocal:</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">inc</span>():</span><br><span class=\"line\">    x = <span class=\"number\">0</span><span class=\"comment\">#外层局部变量，只是读取它的值，</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">fn</span>():</span><br><span class=\"line\">        <span class=\"comment\"># 仅读取x的值:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">f = inc()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f()) <span class=\"comment\"># 1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f()) <span class=\"comment\"># 1，一切正常</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果对变量赋值，由于Python解释器会把x当作函数fn（）的局部变量，他会报错：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">inc</span>():</span><br><span class=\"line\">    x = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">fn</span>():</span><br><span class=\"line\">        <span class=\"comment\"># nonlocal x</span></span><br><span class=\"line\">        x = x + <span class=\"number\">1</span><span class=\"comment\">#对外层变量赋值了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">f = inc()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(f()) <span class=\"comment\"># 1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f()) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lambda：\"><a href=\"#lambda：\" class=\"headerlink\" title=\"lambda：\"></a>lambda：</h3><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p>\n<p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f=<span class=\"keyword\">lambda</span> x:x*x</span><br><span class=\"line\">f</span><br><span class=\"line\">&lt;function &lt;<span class=\"keyword\">lambda</span>&gt; at <span class=\"number\">0x101c6ef28</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以将匿名函数作为返回值返回：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span>: x*x+y*y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"装饰器：\"><a href=\"#装饰器：\" class=\"headerlink\" title=\"装饰器：\"></a>装饰器：</h3><p>函数也是一个对象，而且对象可以赋给变量，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">def</span> <span class=\"title function_\">now</span>():</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;2015-3-25&#x27;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = now</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f()</span><br><span class=\"line\"><span class=\"number\">2015</span>-<span class=\"number\">3</span>-<span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>对象有____name____属性,</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now.__name__</span><br><span class=\"line\"><span class=\"string\">&#x27;now&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.__name__</span><br><span class=\"line\"><span class=\"string\">&#x27;now&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，假设增强now（）函数的功能，，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）</p>\n<p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">log</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kw</span>):</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;call %s():&#x27;</span>%func.__name__)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> func(*args,**kw)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> wrapper</span><br></pre></td></tr></table></figure>\n\n<p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">now</span>():</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;2015-3-25&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</span><br><span class=\"line\">call now():</span><br><span class=\"line\"><span class=\"number\">2015</span>-<span class=\"number\">3</span>-<span class=\"number\">25</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#相当于now=log(now),wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</span></span><br></pre></td></tr></table></figure>\n\n<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">log</span>(<span class=\"params\">text</span>):</span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">decorator</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kw</span>):</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%s %s&#x27;</span>%(text,func.__name__))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> func(*args,**kw)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> decorator</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log(<span class=\"params\"><span class=\"string\">&#x27;execute&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">now</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;2015-3-25&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</span><br><span class=\"line\">execute now():</span><br><span class=\"line\"><span class=\"number\">2015</span>-<span class=\"number\">3</span>-<span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>&#39;now&#39;</code>变成了<code>&#39;wrapper&#39;</code>：</p>\n<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">log</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"><span class=\"meta\">\t@functools.wraps(<span class=\"params\">func</span>)</span></span><br><span class=\"line\">\t<span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*arg,**kw</span>):</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;call %s():&#x27;</span>%func.__name__)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> func(*args,**kw)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> wrapper</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"偏函数：\"><a href=\"#偏函数：\" class=\"headerlink\" title=\"偏函数：\"></a>偏函数：</h3><p><code>int()</code>函数还提供额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">int</span>(<span class=\"string\">&#x27;12345&#x27;</span>, base=<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"number\">5349</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">int</span>(<span class=\"string\">&#x27;12345&#x27;</span>, <span class=\"number\">16</span>)</span><br><span class=\"line\"><span class=\"number\">74565</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">int2</span>(<span class=\"params\">x, base=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(x, base)</span><br></pre></td></tr></table></figure>\n\n<p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2 = functools.partial(<span class=\"built_in\">int</span>, base=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">&#x27;1000000&#x27;</span>)</span><br><span class=\"line\"><span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">&#x27;1010101&#x27;</span>)</span><br><span class=\"line\"><span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int2 = functools.partial(<span class=\"built_in\">int</span>, base=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kw = &#123; <span class=\"string\">&#x27;base&#x27;</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">int</span>(<span class=\"string\">&#x27;10010&#x27;</span>, **kw)</span><br></pre></td></tr></table></figure>\n\n<p>当传入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max2 = functools.partial(<span class=\"built_in\">max</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n\n<p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max2(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n<p>相当于：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">args = (<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"built_in\">max</span>(*args)</span><br></pre></td></tr></table></figure>\n\n<p>结果为<code>10</code>。</p>\n<h2 id=\"模块：\"><a href=\"#模块：\" class=\"headerlink\" title=\"模块：\"></a>模块：</h2><p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点<a href=\"http://docs.python.org/3/library/functions.html\">这里</a>查看Python为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。</p>\n<p>在Python中，举个例子，一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块，一个<code>xyz.py</code>的文件就是一个名字叫<code>xyz</code>的模块。一个.py文件就称之为一个模块（Module）。n的所有内置函数。</p>\n<p>现在，假设我们的<code>abc</code>和<code>xyz</code>这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如<code>mycompany</code>，按照如下目录存放：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mycompany</span><br><span class=\"line\">├─ __init__.py</span><br><span class=\"line\">├─ abc.py</span><br><span class=\"line\">└─ xyz.py</span><br></pre></td></tr></table></figure>\n\n<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。</p>\n<p>现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p>\n<p><code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p>\n<p><strong>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</strong></p>\n<h3 id=\"使用模块：\"><a href=\"#使用模块：\" class=\"headerlink\" title=\"使用模块：\"></a>使用模块：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27; a test module &#x27;</span><span class=\"comment\">#模块的文档注释</span></span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = <span class=\"string\">&#x27;Michael Liao&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    args=sys.argv</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args)==<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">len</span>(args)==<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Hello, %s!&#x27;</span> % args[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Too many arguments!&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>\n<p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；</p>\n<p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael&#39;]</code>。</p>\n<p>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<h3 id=\"作用域：\"><a href=\"#作用域：\" class=\"headerlink\" title=\"作用域：\"></a>作用域：</h3><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_private_1</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello, %s&#x27;</span> % name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_private_2</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hi, %s&#x27;</span> % name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">greeting</span>(<span class=\"params\">name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(name) &gt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _private_1(name)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _private_2(name)</span><br></pre></td></tr></table></figure>\n\n<p>我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样，调用<code>greeting()</code>函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法</p>\n<p>注意：关于代码<em>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:</em> 可能看了之后可能挺晕的，下面举几个例子解释下，希望能让大家对这行的代码的功能有更深的认识，还是那句话，欢迎大家指正定会虚心接受。</p>\n<p>先编写一个测试模块<em>atestmodule.py</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27; a test module &#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">def addFunc(a,b):  </span><br><span class=\"line\">    return a+b  </span><br><span class=\"line\"></span><br><span class=\"line\">print(&#x27;atestmodule计算结果:&#x27;,addFunc(1,1))</span><br></pre></td></tr></table></figure>\n\n<p>再编写一个模块<em>anothertestmodule.py</em>来调用上面的模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27; a test module &#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">import atestmodule</span><br><span class=\"line\"></span><br><span class=\"line\">print(&#x27;调用anothermodule模块执行的结果是：&#x27;,atestmodule.addFunc(12,23))</span><br></pre></td></tr></table></figure>\n\n<p>在刚才两个模块的路径（我的路径为：<em>“C:\\work”</em>）中打开cmd，用命令行运行<em>atestmodule.py</em>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\work&gt;python atestmodule.py</span><br><span class=\"line\">atestmodule计算结果: 2</span><br></pre></td></tr></table></figure>\n\n<p>在刚才两个模块的路径中打开，用命令行运行<em>anothertestmodule.py</em>：</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\work&gt;python anothertestmodule.py</span><br><span class=\"line\">atestmodule计算结果: 2</span><br><span class=\"line\">调用test模块执行的结果是： 35</span><br><span class=\"line\"></span><br><span class=\"line\">#显然，当我运行anothertestmodule.py后第一句并不是调用者所需要的，为了解决这一问题，Python提供了一个系统变量：__name__</span><br><span class=\"line\"></span><br><span class=\"line\">#注：name两边各有2个下划线__name__有2个取值：当模块是被调用执行的，取值为模块的名字；当模块是直接执行的，则该变量取值为：__main__</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>于是乎，被调用模块的测试代码就可以写在if语句里了，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27; a test module &#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">def addFunc(a,b):  </span><br><span class=\"line\">    return a+b  </span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:  </span><br><span class=\"line\">    print(&#x27;atestmodule计算结果:&#x27;,addFunc(1,1))</span><br></pre></td></tr></table></figure>\n\n<p>当再次运行<em>atestmodule.py</em>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\work&gt;python atestmodule.py</span><br><span class=\"line\">atestmodule计算结果: 2</span><br><span class=\"line\"></span><br><span class=\"line\">#结果并没有改变，因为调用atestmodule.py时，__name__取值为__main__，if判断为真，所以就输出上面的结果</span><br></pre></td></tr></table></figure>\n\n<p>当再次运行<em>atestmodule.py</em>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\work&gt;python anothertestmodule.py</span><br><span class=\"line\">调用test模块执行的结果是： 35</span><br><span class=\"line\"></span><br><span class=\"line\">#此时我们就得到了预期结果，不输出多余的结果。能实现这一点的主要原因在于当调用一个module时，此时的__name__取值为模块的名字，所以if判断为假，不执行后续代码。</span><br></pre></td></tr></table></figure>\n\n<p>所以代码<em>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:</em> 实现的功能就是<strong>Make a script both importable and executable</strong>，也就是说可以让模块既可以导入到别的模块中用，另外该模块自己也可执行。</p>\n<h2 id=\"安装第三方模块：\"><a href=\"#安装第三方模块：\" class=\"headerlink\" title=\"安装第三方模块：\"></a>安装第三方模块：</h2><h2 id=\"面向对象编程：\"><a href=\"#面向对象编程：\" class=\"headerlink\" title=\"面向对象编程：\"></a>面向对象编程：</h2><p>上帝</p>\n<p>class 类 (人) instance 实例 (你,我,他) 你会有些属性(身高,年龄,体重) 你会有些技能(吃饭,泡妞)</p>\n<p><code>__init__</code> 方法的主要作用,就是初始化你的属性,这些属性,在上帝初始化你的时候就要赋予给你,比如<code>zhangsan = Person(170,29,50)</code>这时上帝就把你创造出来了，也就是实例化了你，然后，你到底有哪些技能呢，这就看有没有在类里面定义了，如果有定义泡妞的技能，那么你就可以调用泡妞的技能来泡妞，大致就是这样吧，看看下面的例子就更清楚了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\"><span class=\"comment\"># 这里就是初始化你将要创建的实例的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,hight,weight,age</span>):</span><br><span class=\"line\">        self.hight = hight</span><br><span class=\"line\">        self.weight = weight</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义你将要创建的实例所有用的技能</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">paoniu</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;你拥有泡妞的技能&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">eat</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;you can eat&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始创建实例</span></span><br><span class=\"line\">zhangsan=Person(<span class=\"number\">170</span>,<span class=\"number\">50</span>,<span class=\"number\">29</span>)</span><br><span class=\"line\">lisi = Person(<span class=\"number\">175</span>,<span class=\"number\">100</span>,<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你的实例开始使用它的技能</span></span><br><span class=\"line\">zhangsan.paoniu()</span><br><span class=\"line\">lisi.eat()</span><br></pre></td></tr></table></figure>\n\n","categories":[{"name":"python笔记","slug":"python笔记","count":3,"path":"api/categories/python笔记.json"}],"tags":[{"name":"python","slug":"python","count":3,"path":"api/tags/python.json"}]}