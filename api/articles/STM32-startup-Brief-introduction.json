{"title":"STM32 startup Brief introduction","slug":"STM32-startup-Brief-introduction","date":"2021-08-20T13:52:20.000Z","updated":"2021-09-04T15:08:57.483Z","comments":true,"path":"api/articles/STM32-startup-Brief-introduction.json","photos":[],"link":"","excerpt":"STM32启动过程简单讲解STM32F1采用ARM-Cortex-M3内核，对于他的启动以及复位，时钟系统，都是紧密联系的。","covers":["https://img-blog.csdnimg.cn/91fea78749a24399908f990852c34bb0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/8211f5d2bdb7407b82aeffd5bc25e534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/3b696189d08b4a7cbc1ae166ebaec8f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/9b4a00ffdb024f358ace20458b53a9b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/3697c0c9ea1c4e68b44a51efd82ad4bd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/c7f50fce581541a9a3ccaafbd4658162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70","https://img-blog.csdnimg.cn/c6ad5acaa605457a9420e7bfee14785f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70"],"content":"<h1 id=\"STM32启动过程简单讲解\"><a href=\"#STM32启动过程简单讲解\" class=\"headerlink\" title=\"STM32启动过程简单讲解\"></a>STM32启动过程简单讲解</h1><p>STM32F1采用ARM-Cortex-M3内核，对于他的启动以及复位，时钟系统，都是紧密联系的。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=687506&auto=1&height=66\"></iframe>\n\n<span id=\"more\"></span>\n\n<p>以下内容对你对模块的操作帮助可能不太大，但对于你理解其工作模式是有帮助的，对于只想要简单使用单一模块的建议<del>可以不看</del><br><img src=\"https://img-blog.csdnimg.cn/91fea78749a24399908f990852c34bb0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>但是如果要深入了解，那你就要听我哔哔了。我对于时钟系统也是说一下自己知道的，毕竟官方手册中文版讲的很明白了，只需要稍稍解释一下即可。</p>\n<h2 id=\"1-如何启动\"><a href=\"#1-如何启动\" class=\"headerlink\" title=\"1.如何启动\"></a>1.如何启动</h2><p>ARM-CM3处理器结构为哈佛结构，哈佛结构是一种将&#x3D;&#x3D;程序指令存储和数据存储分开&#x3D;&#x3D;的存储器结构。 哈佛结构是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。<br><img src=\"https://img-blog.csdnimg.cn/8211f5d2bdb7407b82aeffd5bc25e534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>数据和程序指令的存储是分开的，芯片主要获取<strong>指令</strong>来执行，指令是由ARM公司固定好的可以被芯片识别的指令，同时这个指令在我们单片机编译时由编译工具链（ToolChains）来生成。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3b696189d08b4a7cbc1ae166ebaec8f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"各种内核\"><br>     <strong>上图为各种内核支持的指令集</strong></p>\n<p>在我们上电的一刹那，单片机就已经触发了复位异常，芯片接着在中断向量表中查找我们的异常指令（如下图的复位异常），进行偏移位置，获取其中内容执行。<br><img src=\"https://img-blog.csdnimg.cn/9b4a00ffdb024f358ace20458b53a9b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>也就是说，我们可以修改复位异常内的内容，让处理器执行我们的程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[芯片上电] -- 触发复位异常 --&gt; B((异常/中断))</span><br><span class=\"line\">B --跳转偏移位置--&gt; D&#123;偏移&#125;</span><br><span class=\"line\">D -- 获取其中内容--&gt;E&#123;执行&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-启动配置\"><a href=\"#2-启动配置\" class=\"headerlink\" title=\"2.启动配置\"></a>2.启动配置</h2><p>通过阅读STM32中文参考手册2.4启动配置，我们可以看到有三种启动方式，<br><img src=\"https://img-blog.csdnimg.cn/3697c0c9ea1c4e68b44a51efd82ad4bd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我们通过改BOOT引脚高低电平状态来使我们的实际的物理存储地址映射到不同存储器的零地址中，BOOT引脚我们是可以在开发板上看到的，下面拿手头的开发板拍一下<br><img src=\"https://img-blog.csdnimg.cn/865c578918c741628c28f795aa56d273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_2,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_10\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/cf4c274e6c744eae81c624594bad68da.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>原理图如下：这里也说明了其启动方式<br><img src=\"https://img-blog.csdnimg.cn/776db5c413014837b2ee6d2e05283a6e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>再继续阅读，我们发现后续是映射到不同存储器的启动空间（实际上是起始的地址）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">    M3内核 --&gt; 系统存储器 : Where am i?</span><br><span class=\"line\">     M3内核 --&gt; FLASH:Where am i?</span><br><span class=\"line\">     M3内核--&gt; 内置SRAM:Where am i?</span><br><span class=\"line\">    内置SRAM : 启动空间</span><br><span class=\"line\">    FLASH : 启动空间</span><br><span class=\"line\">    系统存储器 : 启动空间    </span><br></pre></td></tr></table></figure>\n<p>我们当然首选主闪存存储器，因为他是<strong>可以长期保持数据器件</strong>，拿SRAM静态随机存储器做个对比，SRAM断电后就数据就不存在了，而FLASH烧录之后就会固化到我们的存储器里，可以保持很长时间，就相当于手机上的ROM，保存我们的文件图；而SRAM就是手机的RAM，手机上能运行多少程序主要看他有多大。<br>在生成好的任一工程文件的启动文件（startup_stm32f103xb.s）里你都可以看到我之前提及的中断向量表配置，<br><img src=\"https://img-blog.csdnimg.cn/c7f50fce581541a9a3ccaafbd4658162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>启动文件开头就介绍了他的用途<br>1.初始化堆栈指针<br>2.设置PC指针值<br>3.设置中断向量表<br>4.配置系统时钟<br>5.调用C库函数__main，最终会跳到我们自己的main函数</p>\n<p>之后的DCD就是分配以字节为单位的空间，我们可以看到第一个就是TOP of Stack（堆栈的指针头），第二个就复位异常中断处理，之后便是一系列分配空间，用来准备空间执行我们的程序。<br><img src=\"https://img-blog.csdnimg.cn/c6ad5acaa605457a9420e7bfee14785f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>这里还有很多需要我们查看的地方，有很大部分还使用了汇编语言，大家可以参考手册，并用KEIL的Help–&gt; uVision Help进行索引查找。（不过是全英文）<br><img src=\"https://img-blog.csdnimg.cn/3de881bc0535437a95bd5e7b0d95b711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czA1MDQ=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","categories":[{"name":"底层","slug":"底层","count":1,"path":"api/categories/底层.json"}],"tags":[{"name":"STM32","slug":"STM32","count":10,"path":"api/tags/STM32.json"},{"name":"大一课程准备","slug":"大一课程准备","count":10,"path":"api/tags/大一课程准备.json"},{"name":"启动配置","slug":"启动配置","count":1,"path":"api/tags/启动配置.json"}]}